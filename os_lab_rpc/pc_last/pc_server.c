/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <pthread.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "pc.h"

struct sembuf start_produce[2] = {{BUFF_EMPTY, -1, 0}, {BIN_SEM, -1, 0}};
struct sembuf stop_produce[2] =  {{BIN_SEM, 1, 0}, {BUFF_FULL, 1, 0}};
struct sembuf start_consume[2] = {{BUFF_FULL, -1, 0}, {BIN_SEM, -1, 0}};
struct sembuf stop_consume[2] =  {{BIN_SEM, 1, 0}, {BUFF_EMPTY, 1, 0}};
char buff[SIZE_BUF];
char *addr_prod = buff;
char *addr_cons = buff;
char letter = 'a';

char producer(char **addr_prod, char *letter, const int semid)
{
    if (semop(semid, start_produce, 2) == -1) {
        char err_msg[100];
        sprintf(err_msg, "Error: semop  errno %d", errno);
        perror(err_msg);
        exit(1);
    }
    **addr_prod = *letter;
    char produced = *letter;
    // printf("Producer put %c\n", produced);
    if (produced == 'z')
        *letter = 'a';
    else
        (*letter)++;
    (*addr_prod)++;
    if (semop(semid, stop_produce, 2) == -1) {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }
    return produced;
}

char consumer(char **addr_cons, const int semid)
{
    if (semop(semid, start_consume, 2) == -1) {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }
    char consumed = **addr_cons;
    (*addr_cons)++;
    // printf("Consumer get %c\n", consumed);
    if (semop(semid, stop_consume, 2) == -1) {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }
    return consumed;
}

void signal_handler(int signal_num)
{
    if (semctl(semid, 1, IPC_RMID, NULL) == -1)
    {
        perror("Error delete semafor:");
        exit(1);
    }
    exit(0);
}


bool_t service_1_svc(int *argp, char *result, struct svc_req *rqstp)
{
    if (!argp || !result)
        return 0;

    setbuf(stdout, 0);
	if (signal(SIGINT, signal_handler) == SIG_ERR)
    {
    	perror("Can't signal:\n");
    	exit(EXIT_FAILURE);
    }

    if (*argp == 0)
        *result = producer(&addr_prod, &letter, semid);
    else if (*argp == 1)
        *result = consumer(&addr_cons, semid);
    else
        return 0;

    return 1;
}

int pc_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	return 1;
}
