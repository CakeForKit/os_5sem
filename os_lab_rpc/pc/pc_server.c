/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "pc.h"
#include <sys/sem.h>
#include <sys/stat.h>

#define BINARY 0
#define BEMPTY 1
#define BFULL 2
struct sembuf start_prod[2] = {{BEMPTY, -1, 0}, {BINARY, -1, 0}};
struct sembuf stop_prod[2] = {{BINARY, 1, 0}, {BFULL, 1, 0}};
struct sembuf start_cons[2] = {{BFULL, -1, 0}, {BINARY, -1, 0}};
struct sembuf stop_cons[2] = {{BINARY, 1, 0}, {BEMPTY, 1, 0}};
int semid;

// char buffer[SIZE_BUF];
// char *prod_ptr = buffer;
// char *cons_ptr = buffer;
char *buffer;
char *prod_ptr;
char *cons_ptr;
char alpha = 'a';

bool_t
producer_1_svc(int *argp, char *result, struct svc_req *rqstp)
{
	if (semop(semid, start_prod, 2) == -1) {
		perror("semop");
		exit(1);
	}
	*prod_ptr = alpha;
	*result = alpha;
	printf("Производитель PID=%d положил '%c' ", *argp, *result);
	for (char *cur = buffer; cur < buffer + SIZE_BUF; ++cur) {
		printf("%c", *cur);
	}
	printf("\n");
    prod_ptr++;
	if (prod_ptr == buffer + SIZE_BUF)
		prod_ptr = buffer;
	if (alpha == 'z')
		alpha = 'a';
	else
		alpha++;
	if (semop(semid, stop_prod, 2) == -1) {
		perror("semop");
		exit(1);
	}
	return TRUE;
}

bool_t
consumer_1_svc(int *argp, char *result, struct svc_req *rqstp)
{
	if (semop(semid, start_cons, 2) == -1) {
		perror("start consume semop");
		exit(1);
	}
	*result = *cons_ptr;
	printf("Потребитель PID=%d взял '%c'      ", *argp, *result);
	*cons_ptr = '-';
	for (char *cur = buffer; cur < buffer + SIZE_BUF; ++cur) {
		printf("%c", *cur);
	}
	printf("\n");
    cons_ptr++;
	if (cons_ptr == buffer + SIZE_BUF)
		cons_ptr = buffer;
	if (semop(semid, stop_cons, 2) == -1) {
		perror("stop consume semop");
		exit(1);
	}
	return TRUE;
}

int
pc_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}

int init_sem(const char *fn) {
	int perms = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
	key_t key;
	key = ftok(fn, 1);
    if (key == -1){
        perror("ftok"); 
        return -1;
    }
	semid = semget(key, 3, IPC_CREAT | perms);
	if (semid == -1) {
        perror("semget"); 
        return -1;
    }
    if (semctl(semid, BINARY, SETVAL, 1) == -1) {
        perror("semctl"); 
        return -1;
    }
    if (semctl(semid, BEMPTY, SETVAL, SIZE_BUF) == -1) {
        perror("semctl"); 
        return -1;
    }
    if (semctl(semid, BFULL, SETVAL, 0) == -1) {
        perror("semctl"); 
        return -1;
    }
	buffer = calloc(SIZE_BUF, sizeof(char));
	if (buffer == NULL) {
		perror("calloc");
		return -1;
	}
	for (char *cur = buffer; cur < buffer + SIZE_BUF; ++cur) {
		*cur = '-';
	}
	prod_ptr = buffer;
	cons_ptr = buffer;
	return 0;
}

int free_sem() {
	if (semctl(semid, 0, IPC_RMID) == -1) {
        perror("semctl"); 
        return -1;
    }
	free(buffer);
	return 0;
}