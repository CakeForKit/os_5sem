Для того, чтобы дизассемблировать код прерывания (напомню, нам нужно int 8h) надо как минимум знать, по какому адресу оно расположено.
Узнать это есть аж три способа (по крайней мере, мне известно столько):

1) Написать прогу, которая получает его адрес (// вы забыли про ассемблер, а он про вас нет, сучки!)
Для этого используется 35h функция прерывания 21h: в качестве аргументов она принимает номер прерывания в 16-чной СС в AL,
возвращает сегмент в регистре ES и смещение в регистре BX
Пример кода - в репозитории, смотреть адрес в регистрах в проге через cv

2) Посмотреть адрес через отладчик AFD (то ли первая, то ли вторая лаба по ассмеблеру, идёт в комплекте с MASM'ом)

Лирическое отступление: для описания адресов прерываний в ДОСе используется т.н "таблица векторов прерываний", которая отжирает под себя весь _первый_ мегабайт ОЗУ
(т.е начиная с адреса 0000:0000), адрес одного прерывания (2 байта сегмент+2 байта смещение) занимает, очевидно, 4 байта.
Проводим нехитрые вычисления: 8h * 4h = 20h и получаем, что адрес int 8h расположен по адресу 0000:0020

Лезем в AFD и вводим 'd 0000:0020' без кавычек - и получаем няшную последовательность байт (нас интересуют байты с 20-го по 23-й включительно, они иногда странным образом объединяются, см. скрин)
У меня это выглядит вот так: http://puu.sh/bqt4q/2b1161ac08.png
АТТЕНШЕН: адрес записан в little-endian, поэтому у меня, например, реальный адрес - F000:FEA5 (далеко не факт, что у вас он будет таким же)

3) Вот и добрались до самого вкусного: в комплекте в Sourcer (по крайней мере, версии 8.01) идёт утилита intview.exe,
которая показывает адреса всех прерываний: http://puu.sh/bqtbq/bdbf3b4730.png
Нас, как вы помните, интересует int 8h, которое расположено в этой табличке угадайте под каким номером

Дизассемблирование:
Адрес получили, теперь по нему надо получить дизассмеблированный код прерывания, здесь опять же мне известно аж два способа:

1) Лезем в многострадальный AFD и вводим 'd адрес' (в моём случае - d f000:fea5)
Получаем, опять же, няшную последовательность байт с расшифровкой, какую ассемблерную команду они представляют, расшифровку списываем
Пример - http://puu.sh/bqtCc/706ec3dcaa.png

2) Запускаем Sourcer (или с торрентов с параметром sr.exe DS -dos, или Рязановой без параметров)
Жмём b и задаём адрес начала дизассмеблирования (слева внизу) (вводим сегмент, жмём энтер, вводим смещение, жмём энтер)
Аналогично жмём e и задаём адрес окончания дизассемблирования (с запасом хватит смещения+200 в 16-чной системе, заюзайте виндовый калькулятор, я даже поменьше брал)
При желании можно ткнуть O и поменять имя выходного файла, по умолчанию он называется TEST.LST
Дальше жмём на p, пока значение в Passes (справа внизу) не станет равно 9 - для гарантии, что всё корректно дизассемблируется
Пример настройки у меня: http://puu.sh/bqtPe/063eea3075.png
Жмём g, получаем дизассемблированный файл с кодом
Пример выходного файла TEST.LST (из-под DosBOX) также валяется тут в репозитории

* © влад, артём; https://bitbucket.org/RogueNalan/iu7-5sem-labs